# Проектирование и разработка системы

> **Цель:** Правильно спроектировать систему перед реализацией — определить требования, разбить на модули, продумать архитектуру. Это основа для обоснования решений в дипломе.

## 1. Анализ требований

### 1.1 Зачем нужен анализ требований

Для диплома это критично:
- **Обосновать актуальность** — какую проблему решает система
- **Определить границы** — что входит в scope, а что нет
- **Сформулировать критерии успеха** — как понять, что система работает правильно
- **Документировать для диплома** — раздел "Постановка задачи"

### 1.2 Типы требований

**Функциональные требования** — что система должна делать:
- Импорт данных из источников X, Y
- Обработка запросов в режиме реального времени
- Визуализация результатов в виде дашборда
- Автоматическое оповещение при обнаружении аномалий

**Нефункциональные требования** — как система должна работать:
- **Производительность:** обработка 1000 запросов/сек
- **Масштабируемость:** поддержка до 1M записей
- **Надёжность:** доступность 99.9%
- **Безопасность:** шифрование данных, аутентификация
- **Usability:** интуитивный интерфейс для неспециалистов

**Как описывать требования:**

```markdown
**FR-1: Импорт данных**
Система должна импортировать данные из CSV файлов формата X.

**FR-2: Детекция аномалий**
Система должна обнаруживать аномалии в режиме реального времени 
с задержкой не более 5 секунд.

**NFR-1: Производительность**
Система должна обрабатывать минимум 100 записей в секунду.
```

> **Совет:** Используйте Use Case диаграммы для визуализации сценариев. Подробнее в [145-diagrams-notations.md](145-diagrams-notations.md).

---

## 2. Декомпозиция и архитектура

### 2.1 Разбиение на модули (для студента-одиночки)

**Принцип:** Разделяй и властвуй — даже если вы один, разбивайте проект на логические модули.

**Типовая структура для backend системы:**

```
project/
├── data/           # Модуль работы с данными
│   ├── loader.py   # Загрузка из источников
│   ├── processor.py # Предобработка
│   └── storage.py  # Работа с БД
├── models/         # ML модели или бизнес-логика
│   ├── detector.py # Основной алгоритм
│   └── evaluator.py # Оценка результатов
├── api/            # REST API (если есть)
│   ├── routes.py
│   └── schemas.py
├── utils/          # Вспомогательные функции
└── tests/          # Тесты
```

**Для ML/Data Science проекта:**

```
project/
├── data/           # Работа с данными
├── features/       # Feature engineering
├── models/         # Обучение и инференс
├── evaluation/     # Метрики и визуализация
├── notebooks/      # EDA и эксперименты
└── scripts/        # Автоматизация
```

**Зачем это нужно:**
- ✅ Код проще понимать и поддерживать
- ✅ Легче тестировать отдельные части
- ✅ В дипломе можно показать модульную структуру
- ✅ Проще добавлять новую функциональность

### 2.2 Выбор архитектурного подхода

| Подход | Когда использовать | Для диплома |
|--------|-------------------|-------------|
| **Монолит** | Простые системы, MVP, ограниченное время | ✅ Оптимально |
| **Модульный монолит** | Средняя сложность, нужна расширяемость | ✅ Хорошо |
| **Микросервисы** | Только если это требование задачи | ⚠️ Избыточно для одного |

> **Рекомендация:** Начните с монолита, но структурируйте код модульно. Если понадобится — легко разнесёте на сервисы.

### 2.3 Как проектировать взаимодействие модулей

**Пример: Система детекции аномалий IoT-датчиков**

```
1. data_loader → загружает данные с датчиков
2. preprocessor → очищает и нормализует
3. feature_extractor → извлекает признаки
4. anomaly_detector → применяет модель (LSTM/Isolation Forest)
5. alerter → отправляет уведомления
6. visualizer → строит графики
```

**Принципы:**
- Каждый модуль делает одну вещь хорошо
- Модули общаются через чёткие интерфейсы (функции/классы)
- Минимум зависимостей между модулями

> **Для диаграмм:** Используйте Component Diagram и Sequence Diagram — см. [145-diagrams-notations.md](145-diagrams-notations.md)

---

## 3. Выбор технологий

**Краткий процесс выбора:**

1. **Определить слои системы:**
   - Хранение данных (БД)
   - Обработка/логика (backend)
   - Представление (frontend/визуализация)
   - ML модели (если есть)

2. **Выбрать 2-3 варианта для каждого слоя**

3. **Сравнить по критериям:**
   - Знакомство с технологией
   - Документация и community
   - Соответствие требованиям проекта

4. **Обосновать в дипломе**

> **Детали выбора стека:** См. [150-architecture-choice.md](150-architecture-choice.md) — там полная методология с примерами

**Пример обоснования для диплома:**

> Для реализации backend выбран FastAPI по следующим причинам:
> 1. Нативная поддержка async операций — критично для обработки данных от 100+ датчиков
> 2. Автоматическая генерация OpenAPI документации — упрощает интеграцию
> 3. Высокая производительность (2-3x быстрее Flask по бенчмаркам [источник])
> 4. Встроенная валидация данных через Pydantic
>
> Для БД выбран PostgreSQL + расширение TimescaleDB:
> 1. Оптимизация для time-series данных (основной тип в проекте)
> 2. Поддержка ACID транзакций
> 3. Зрелое решение с большим community
> 4. Бесплатная лицензия

---

## 4. Тестирование (для студента-одиночки)

### 4.1 Зачем тестировать в дипломе

- ✅ Доказать работоспособность системы
- ✅ Избежать регрессии при доработках
- ✅ Показать профессионализм на защите
- ✅ Упростить отладку

### 4.2 Минимальный набор тестов

**1. Unit тесты ключевых функций:**
- Основные алгоритмы (детекция аномалий, классификация)
- Обработка данных (предобработка, валидация)
- Бизнес-логика

**2. Integration тесты (если есть API):**
- Основные endpoints работают
- Корректная обработка ошибок

**3. Manual тесты:**
- Прогон основных сценариев использования
- Проверка на реальных данных

**Цель для диплома:** Coverage >50-70% для core модулей

> **Примеры кода тестов:** См. [210-code-examples.md](210-code-examples.md)

### 4.3 Простая стратегия Git для одного

**Базовый подход:**
```bash
# Основная ветка
main (или master)

# Короткие feature ветки при необходимости
feat/anomaly-detection
fix/data-loader-bug

# Теги для важных версий
v0.1.0 — MVP
v0.2.0 — финальная версия для диплома
```

**Коммиты:**
```bash
# Хорошо
git commit -m "feat: добавить детекцию аномалий LSTM"
git commit -m "fix: исправить загрузку CSV с пустыми значениями"
git commit -m "docs: обновить README с примерами запуска"

# Плохо
git commit -m "changes"
git commit -m "update"
```

> **Детали организации репозитория:** См. [160-project-organization.md](160-project-organization.md)

---

## 5. Документация для диплома

### 5.1 Обязательная документация

**README.md в репозитории:**
- Описание проекта
- Требования (версии Python, библиотеки)
- Инструкции по установке
- Инструкции по запуску
- Примеры использования

**Диаграммы в дипломе:**
- Use Case — сценарии использования
- Component/Module — структура системы
- ERD — структура БД (если есть)
- Sequence — взаимодействие компонентов (1-2 ключевых сценария)

> **Как делать диаграммы:** См. [145-diagrams-notations.md](145-diagrams-notations.md)

**Комментарии в коде:**
- Docstrings для классов и функций
- Объяснение сложной логики
- Ссылки на источники алгоритмов

### 5.2 Опциональная документация

**API документация** (если есть REST API):
- Автогенерация через Swagger/FastAPI
- Или вручную в README

**Видео-демонстрация** (3-5 минут):
- Запуск системы
- Основные сценарии использования
- Интерпретация результатов
- Можно вставить ссылку в презентацию

> **Структура проекта:** См. [160-project-organization.md](160-project-organization.md)

---

## 6. Типичные ошибки и рекомендации

### ❌ Что НЕ делать

1. **Начинать кодить без проектирования**
   - Плохо: сразу писать код без понимания структуры
   - Хорошо: потратить 1-2 дня на проектирование модулей

2. **Делать всё в одном файле**
   - Плохо: `main.py` на 2000 строк
   - Хорошо: разбить на модули по 200-300 строк

3. **Игнорировать тестирование**
   - Плохо: "Потом напишу тесты"
   - Хорошо: писать тесты параллельно с кодом

4. **Хардкодить настройки**
   - Плохо: пароли и URL прямо в коде
   - Хорошо: `.env` файлы + `python-dotenv`

5. **Не делать коммиты**
   - Плохо: один коммит перед защитой
   - Хорошо: коммиты каждые 1-2 часа работы

### ✅ Рекомендации для студента

1. **Начните с MVP** — сделайте минимально рабочую версию за 1-2 недели
2. **Работайте итерациями** — сначала core функциональность, потом расширения
3. **Тестируйте постепенно** — не пытайтесь покрыть всё сразу
4. **Документируйте по ходу** — пишите README и комментарии сразу, а не в конце
5. **Просите фидбек** — показывайте код научруку или коллегам

---

## 7. Чек-листы

### Перед началом реализации

- [ ] Сформулированы функциональные требования (5-10 пунктов)
- [ ] Определены нефункциональные требования (производительность, надёжность)
- [ ] Нарисована схема модулей/компонентов системы
- [ ] Выбран технологический стек с обоснованием
- [ ] Создан Git репозиторий
- [ ] Написан базовый README

### Перед защитой диплома

- [ ] Реализованы все ключевые требования
- [ ] Написаны тесты для core функциональности (coverage >50%)
- [ ] README содержит инструкции по запуску
- [ ] Код разбит на логические модули
- [ ] Сделаны диаграммы для диплома (Use Case, Component, ERD)
- [ ] Система запускается одной командой
- [ ] Записана видео-демонстрация (опционально)
- [ ] Код залит на GitHub/GitLab

---

## Связь с другими гайдами

- **Диаграммы:** [145-diagrams-notations.md](145-diagrams-notations.md) — какие диаграммы рисовать
- **Выбор технологий:** [150-architecture-choice.md](150-architecture-choice.md) — матрица критериев
- **Организация проекта:** [160-project-organization.md](160-project-organization.md) — структура репозитория
- **Примеры кода:** [210-code-examples.md](210-code-examples.md) — конкретные примеры

---

**Помните:** Хорошее проектирование экономит время на реализации и избавляет от переделок перед защитой!
