# Выбор технического стека

Документ описывает **комплексный методологический подход к выбору технического стека** для дипломной работы. Это структурированная система принятия решений, которую можно применить к любому проекту:

***

# Методология выбора технического стека для дипломной работы

## **Шаг 1: Декомпозиция архитектуры проекта**

Разделите проект на функциональные слои и определите технические требования для каждого:

### **1.1 Уровни архитектуры**

| Слой | Назначение | Ключевые вопросы |
| :-- | :-- | :-- |
| **Data Layer** (Хранение) | Где и как хранятся данные | Структурированные? Объём? Скорость записи/чтения? |
| **Processing Layer** (Обработка) | Где происходят вычисления | Batch/Stream? CPU/GPU? Распределённые вычисления? |
| **Logic Layer** (Бизнес-логика) | Где реализованы алгоритмы | Монолит/микросервисы? Синхронно/асинхронно? |
| **API Layer** (Интерфейс взаимодействия) | Как компоненты общаются | REST/GraphQL/gRPC? WebSocket? |
| **Presentation Layer** (UI/UX) | Как пользователь взаимодействует | Web/Mobile/Desktop? SPA/MPA? |
| **Infrastructure Layer** (Инфраструктура) | Где это развёрнуто | Локально/Cloud? Docker/K8s? CI/CD? |


***

## **Шаг 2: Матрица критериев выбора**

Для каждого компонента стека оцените по следующим критериям:

### **2.1 Технические критерии**

| Критерий | Описание | Примеры вопросов |
| :-- | :-- | :-- |
| **Производительность** | Скорость обработки, latency | Обрабатывает ли 1000+ запросов/сек? |
| **Масштабируемость** | Горизонтальное/вертикальное расширение | Растёт ли нагрузка в будущем? |
| **Надёжность** | Отказоустойчивость, ACID/BASE | Критична ли потеря данных? |
| **Гибкость** | Адаптация к изменениям требований | Меняется ли схема данных часто? |
| **Интероперабельность** | Интеграция с другими системами | Нужна ли интеграция с legacy? |

### **2.2 Практические критерии**

| Критерий | Описание | Примеры вопросов |
| :-- | :-- | :-- |
| **Зрелость экосистемы** | Наличие библиотек, инструментов | Есть ли готовые решения задачи? |
| **Документация** | Качество и полнота документации | Легко ли найти примеры? |
| **Сообщество** | Активность, поддержка | Есть ли ответы на Stack Overflow? |
| **Лицензирование** | Open-source/Commercial | Можно ли использовать бесплатно? |
| **Кривая обучения** | Сложность освоения | Знаком ли студент с технологией? |
| **Воспроизводимость** | Простота репликации результатов | Можно ли запустить на другом ПК? |


***

## **Шаг 3: Матрица выбора по компонентам**

### **3.1 Базы данных: SQL vs NoSQL**

| Критерий | SQL (PostgreSQL, MySQL) | NoSQL (MongoDB, Redis, Neo4j) |
| :-- | :-- | :-- |
| **Структура данных** | Фиксированная схема, нормализация | Гибкая схема, документы, графы |
| **Тип данных** | Табличные, реляционные | Документы, key-value, графы, временные ряды |
| **Транзакции** | ACID, строгая консистентность | Eventual consistency, BASE |
| **Сложность запросов** | JOIN, агрегация, подзапросы | Простые запросы, денормализация |
| **Масштабируемость** | Вертикальная (сложнее горизонтальная) | Горизонтальная (шардинг) |
| **Примеры задач** | Финансы, медицина, учёт | IoT-телеметрия, соцсети, графы связей |

**Рекомендация:**

- SQL — если требуется строгая консистентность, сложные связи, ACID-транзакции
- NoSQL — если нужна высокая скорость записи, гибкость схемы, горизонтальное масштабирование
- **Гибридный подход** — часто оптимален: SQL для структурированных данных + NoSQL для динамических/потоковых


### **3.2 Backend Framework**

| Критерий | Flask | Django | FastAPI | Express.js |
| :-- | :-- | :-- | :-- | :-- |
| **Сложность** | Минимальная | Высокая (full-stack) | Средняя | Средняя |
| **Скорость разработки** | Быстрый MVP | Быстрый для CRUD | Быстрый + async | Быстрый |
| **Производительность** | Средняя | Средняя | Высокая (async) | Высокая |
| **Встроенные возможности** | Минимум (расширяемо) | ORM, admin, auth | Async, документация API | Минимум |
| **Лучше для** | Простые API, микросервисы | Корпоративные приложения | Высоконагруженные API | Node.js экосистема |

**Рекомендация:**

- Flask — простые прототипы, быстрые API
- Django — полноценные веб-приложения с админкой
- FastAPI — высокопроизводительные async API, современные стандарты


### **3.3 Frontend: SPA vs MPA**

| Критерий | SPA (React, Vue, Angular) | MPA (Django templates, Jinja2) |
| :-- | :-- | :-- |
| **Интерактивность** | Высокая, real-time | Низкая, перезагрузка страниц |
| **Производительность** | Быстрая после загрузки | Медленная при навигации |
| **SEO** | Требует SSR/pre-rendering | Отличное из коробки |
| **Сложность разработки** | Выше (отдельный стек) | Ниже (монолит) |
| **Состояние приложения** | На клиенте (Redux, Vuex) | На сервере (сессии) |
| **Лучше для** | Дашборды, real-time аналитика | Административные панели, формы |

**Рекомендация:**

- SPA — если нужна высокая интерактивность, работа с графиками, real-time обновления
- MPA — если проект простой, важно SEO, нет требований к динамике


### **3.4 API архитектура**

| Критерий | REST | GraphQL | gRPC | WebSocket |
| :-- | :-- | :-- | :-- | :-- |
| **Простота** | Высокая | Средняя | Низкая | Средняя |
| **Гибкость запросов** | Фиксированные endpoints | Клиент выбирает поля | Строгий контракт | Двусторонняя связь |
| **Производительность** | Средняя | Средняя | Высокая | Высокая для real-time |
| **Типизация** | Опциональная | Схема (SDL) | Proto файлы | Опциональная |
| **Лучше для** | CRUD, стандартные API | Сложные запросы, фронтенд-ориентированные | Микросервисы, низкая latency | Real-time, чаты, мониторинг |

**Рекомендация:**

- REST — стандарт для большинства проектов
- GraphQL — если фронтенд требует гибкости в запросах
- WebSocket — для real-time обновлений (мониторинг, уведомления)


### **3.5 Обработка данных и ML**

| Критерий | scikit-learn | TensorFlow/PyTorch | XGBoost/LightGBM | Apache Spark |
| :-- | :-- | :-- | :-- | :-- |
| **Задачи** | Классические ML | Deep Learning | Градиентный бустинг | Распределённая обработка |
| **Производительность** | Средняя | Высокая (GPU) | Высокая для табличных | Высокая для Big Data |
| **Кривая обучения** | Низкая | Высокая | Средняя | Высокая |
| **Масштаб данных** | До 1M записей | До 100M+ | До 10M | 100M+ |
| **Лучше для** | Прототипы, research | Computer vision, NLP | Табличные данные | Пайплайны Big Data |

**Рекомендация:**

- scikit-learn — базовый выбор для классических задач ML
- XGBoost/LightGBM — лучший выбор для табличных данных (конкурсы Kaggle)
- TensorFlow/PyTorch — для deep learning (CV, NLP, временные ряды)


### **3.6 Визуализация**

| Критерий | Matplotlib | Plotly/Dash | D3.js | Tableau/Power BI |
| :-- | :-- | :-- | :-- | :-- |
| **Интерактивность** | Статичная | Интерактивная | Полный контроль | Интерактивная |
| **Сложность** | Низкая | Средняя | Высокая | Низкая (no-code) |
| **Web-интеграция** | Экспорт изображений | Встроенные компоненты | Нативная | Embed |
| **Лучше для** | Статичные отчёты, research | Web-дашборды, прототипы | Кастомная визуализация | Бизнес-аналитика |

**Рекомендация:**

- Matplotlib/seaborn — для исследовательского анализа и статичных отчётов
- Plotly/Dash — для интерактивных веб-дашбордов
- D3.js — если нужна полная кастомизация

***

## **Шаг 4: Процесс принятия решения**

### **4.1 Алгоритм выбора**

```
ДЛЯ КАЖДОГО КОМПОНЕНТА:
1. Определить функциональные требования
2. Определить нефункциональные требования (производительность, масштабируемость)
3. Оценить ограничения (время, знания, доступность)
4. Составить short-list из 2-3 вариантов
5. Провести сравнительный анализ по критериям
6. Выбрать оптимальный вариант
7. Обосновать выбор в работе
```


### **4.2 Пример применения**

**Задача:** Система мониторинга качества воздуха в городе

**Декомпозиция:**

- **Data:** IoT-датчики → временные ряды, 1000+ точек/мин
- **Storage:** Нужна быстрая запись → TimescaleDB (PostgreSQL для временных рядов)
- **Processing:** Реал-тайм аналитика → Python + pandas/numpy
- **ML:** Прогноз загрязнений → LSTM (PyTorch) + ARIMA (statsmodels)
- **API:** Real-time данные → WebSocket + REST (FastAPI)
- **Frontend:** Интерактивные карты → SPA (React + Leaflet)
- **Viz:** Real-time графики → Plotly/Dash

**Обоснование:**
> "Для хранения временных рядов от датчиков выбрана TimescaleDB — расширение PostgreSQL, оптимизированное для временных данных с высокой скоростью записи. Backend реализован на FastAPI для поддержки асинхронных WebSocket соединений, обеспечивающих обновление данных в реальном времени. Frontend выполнен как SPA на React с библиотекой Leaflet для визуализации географических данных и Plotly для интерактивных графиков."

***

## **Шаг 5: Оформление в дипломе**

### **5.1 Раздел "Выбор технологического стека"**

Структура:

1. **Анализ требований** (функциональные + нефункциональные)
2. **Сравнение альтернатив** (таблица с критериями)
3. **Обоснование выбора** (почему именно эти технологии)
4. **Архитектурная диаграмма** (как компоненты связаны)
5. **Оценка рисков** (что может пойти не так и как минимизировать)

### **5.2 Пример таблицы сравнения**

| Критерий | PostgreSQL | MongoDB | Обоснование |
| :-- | :-- | :-- | :-- |
| Структура данных | Фиксированная | Гибкая | **PostgreSQL** — данные табличные и структурированные |
| Транзакции | ACID | BASE | **PostgreSQL** — критична консистентность |
| Масштабируемость | Вертикальная | Горизонтальная | **PostgreSQL** — прогнозируемая нагрузка до 1M записей |
| **Итоговый выбор** | ✓ | — | PostgreSQL оптимален для задачи |


***

## **Шаг 6: Чек-лист перед финальным выбором**

- [ ] Технология решает задачу (функциональность)
- [ ] Производительность достаточна для прогнозируемой нагрузки
- [ ] Есть документация и примеры на русском/английском
- [ ] Студент знаком с технологией или может освоить за разумное время
- [ ] Лицензия позволяет использовать в образовательных целях
- [ ] Технология поддерживается сообществом (активные обновления)
- [ ] Результаты воспроизводимы на другом окружении
- [ ] Выбор обоснован в работе с аргументацией

***

Этот подход позволяет **систематически и обоснованно** выбирать технологии для любого дипломного проекта, демонстрируя научный подход и инженерную зрелость.